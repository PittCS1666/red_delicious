use bevy::prelude::*;
use crate::{player, enemy};
use crate::input::InputState;

pub const TICKRATE: u8 = 30;
const TICKLEN_S: f32 = 1. / TICKRATE as f32;

#[derive(Resource)]
pub struct TickNum(pub u16);

#[derive(Default, Clone, Copy)]
pub struct GameState {
    pub players: [player::Player; player::MAX_PLAYERS],
    pub player_count: usize,
    pub enemies: [enemy::Enemy; enemy::MAX_ENEMIES],
    pub enemy_count: usize
}

// host-kept record of a tick
#[derive(Default, Clone, Copy)]
pub struct Tick {
    pub inputs: [InputState; player::MAX_PLAYERS],  // sent from host inputs and client packets
    pub game_state: GameState,  // set to clients from host
}

//TODO i have no idea if 32 is the right number
const TICK_BUFFER_LEN: usize = 32;
#[derive(Resource)]
pub struct TickBuffer {
    buffer: [Tick; TICK_BUFFER_LEN],
    index: usize
}

impl TickBuffer {
    fn get(&self, i:isize) -> &Tick {
        let i = (self.index as isize + i) % TICK_BUFFER_LEN as isize;
        &self.buffer[i as usize]
    }
    fn increment(&mut self) {
        self.index += 1;
        self.index %= TICK_BUFFER_LEN;
    }
}


pub fn setup(mut commands: Commands) {
    commands.insert_resource(FixedTime::new_from_secs(TICKLEN_S));
    commands.insert_resource(TickNum { 0: 0 });
    commands.insert_resource(TickBuffer{
        buffer: [Tick::default(); TICK_BUFFER_LEN],
        index: 0,
    });
}

// might want to split client functions and host functions into different files

// this definitely takes an event or something LOL
/*pub fn handle_packet_client() {
    // receive UDP packet and handle it
}*/


pub fn tick_host(
    mut input_state: ResMut<InputState>,
    mut tb: ResMut<TickBuffer>
) {
    //tb.inputs[0] = input_state;
    // clone data from shared resources into game_state_history, generated by systems
    // TODO compute game_state_history.now() across all systems
    // TODO send everyone a copy of game_state_history.now()
    //tb.increment();
}

pub fn tick_client(mut input_state: ResMut<InputState>) {
    // TODO send the server a copy of input_state
}

pub fn increment_tick(mut tick_num: ResMut<TickNum>) {
    tick_num.0 += 1;
}
