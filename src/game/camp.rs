use bevy::prelude::*;
use rand::Rng;
use crate::AppState;
use crate::game::enemy;
use crate::Atlas;
use crate::map::{MAPSIZE, TILESIZE, CampNodes};
use crate::components::PowerUpType;
use crate::components::*;

use crate::buffers::*;

const CAMP_ENEMIES: u8 = 1;

pub struct CampPlugin;

impl Plugin for CampPlugin{
    fn build(&self, app: &mut App){
        app.add_systems(OnEnter(AppState::Game), setup);
        //app.add_systems(OnEnter(AppState::Game), spawn_camp_enemy);
        app.add_systems(Update,(
            handle_camp_clear,
        ));
    }
}

pub fn setup(
    mut commands: Commands,
    entity_atlas:Res<Atlas>,
    camp_nodes: Res<CampNodes>,
) {

    // spawn a camp at a specified position

    //placeholder variables for initialization
    
    let pos: Vec2 = get_spawn_vec(0., 0.);
    println!("x is {} y is {}", pos.x, pos.y);


    //TODO: spawn enemies at a camp in the spawn_camp_enemy function instead of just in setup (part of prefab implementation)
    
    //TODO: randomly generate a grade (prefab id) for a camp
    //TODO: make more prefabs for camps
    //TODO: spawn decorations in the camp (part of making more prefabs too)
    //TODO: respawn enemies in a camp after a certain amount of time

    //TODO: Iterate through the MST of camps generated by perlin noise and spawn a camp at each node
    let mut campid: u8 = 0; 
    let mut rng = rand::thread_rng();

    for camps in camp_nodes.0.iter(){
        println!("x: {}, y: {}", camps.x, camps.y);

        // x-y position of the camp
        let camp_pos: Vec2 = get_spawn_vec(camps.x, camps.y);
        // determines camp/enemy type
        let camp_grade: u8 = rng.gen_range(1..=5);

        let pb = PosBuffer(CircularBuffer::new_from(camp_pos));
        commands.spawn((
            Camp(campid),
            pb,
            Grade(camp_grade),
            CampEnemies{
                max_enemies: CAMP_ENEMIES,
                current_enemies: CAMP_ENEMIES,
            },
            CampStatus{
                status: true,
            },
            //spawn decorations here
        ));

        //spawn enemies for this camp
        // let mut x_off: f32 = 100.;
        // let mut y_off: f32 = 100.;
        // for n in 0..CAMP_ENEMIES{

            //generate a random powerup to drop from each enemy
            let powerups: [PowerUpType; 5] = [PowerUpType::DamageDealtUp, PowerUpType::DamageReductionUp, PowerUpType::AttackSpeedUp, PowerUpType::MovementSpeedUp, PowerUpType::MaxHPUp];
            let rpu = rng.gen_range(0..powerups.len());
            //account for type
            let camp_grade = camp_grade as i32;

            enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(camp_pos.x, camp_pos.y), camp_grade, powerups[rpu]);
            
            // increase x and y offsets to stagger enemies
            // x_off += rng.gen_range((50.)..(200.));
            // if x_off > 350.{
            //     x_off = 50.;
            //     y_off += 250.;
            // }

        //end for
        //}
            // enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(camp_pos.x - 70., camp_pos.y), camp_grade, powerups[rpu]);
            // enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(camp_pos.x - 20., camp_pos.y + 100.), camp_grade, powerups[rpu]);
            // enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(camp_pos.x + 40. , camp_pos.y + 20.), camp_grade, powerups[rpu]);
            // enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(camp_pos.x + 100., camp_pos.y + 100.), camp_grade, powerups[rpu]);


        campid+=1;
    }
    //get spawn vec can later be replaced with some noise thing to randomly generate where its placed

}

pub fn handle_camp_clear(
    mut camp_query: Query<(&Camp, &CampEnemies, &mut CampStatus), With<Camp>>,
){
    for (camp_num, enemies_in_camp, mut camp_status) in camp_query.iter_mut(){
        
        // only let this happen for camps that are currently active
        if camp_status.status {
            //set the camp as cleared if all enemies are gone
            if enemies_in_camp.current_enemies == 0 {
                camp_status.status = false;
                println!("camp {} cleared", camp_num.0)
            }
            
        }
    }
}

// convert given row and col into x and y coordinates. Returns a vec2 of these coordinates
fn get_spawn_vec(row: f32, col:f32) -> Vec2{
    let x_coord = TILESIZE as f32 * (row - (MAPSIZE as f32/2. + 0.5));
    let y_coord = TILESIZE as f32 * ((MAPSIZE as f32/2. - 0.5) - col);

    Vec2::new(x_coord, y_coord)
}