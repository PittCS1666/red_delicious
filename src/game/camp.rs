use bevy::prelude::*;
use crate::AppState;
use crate::game::enemy;
use crate::Atlas;
use crate::map::{MAPSIZE, TILESIZE};
use crate::components::PowerUpType;
use crate::components::*;

use crate::buffers::*;

#[derive(Component)]
pub struct ListOfCamps;

pub struct CampPlugin;

impl Plugin for CampPlugin{
    fn build(&self, app: &mut App){
        app.add_systems(OnEnter(AppState::Game), setup);
        //app.add_systems(OnEnter(AppState::Game), spawn_camp_enemy);
        app.add_systems(Update,(
            handle_camp_clear,
        ));
    }
}

pub fn setup(
    mut commands: Commands,
    entity_atlas:Res<Atlas>,
) {

    // spawn a camp at a specified position

    //placeholder variables for initialization
    const CAMP_GRADE: u8 = 1;
    const CAMP_ENEMIES: u8 = 5;
    let pos: Vec2 = get_spawn_vec(138., 109.);

    //TODO: spawn enemies at a camp in the spawn_camp_enemy function instead of just in setup (part of prefab implementation)
    //TODO: Iterate through the MST of camps generated by perlin noise and spawn a camp at each node
    //TODO: randomly generate a grade (prefab id) for a camp
    //TODO: make more prefabs for camps
    //TODO: spawn decorations in the camp (part of making more prefabs too)
    //TODO: respawn enemies in a camp after a certain amount of time

    //get spawn vec can later be replaced with some noise thing to randomly generate where its placed
    let pb = PosBuffer(CircularBuffer::new_from(pos));
    commands.spawn((
        Camp(1),
        pb,
        Grade{
            grade: CAMP_GRADE,
        },
        CampEnemies{
            max_enemies: 5,
            current_enemies: 5,
        },
        CampStatus{
            status: true,
        },
    ));

}

//TODO: Implement this 
pub fn spawn_camp_enemy(
    mut commands: Commands,
    entity_atlas:Res<Atlas>,
    campid: u8,
    camp_grade: u8,
    pos: Vec2,
){
    let camp_grade = camp_grade as i32;
    enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(pos.x - 100., pos.y - 100.), camp_grade, PowerUpType::DamageDealtUp);
    enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(pos.x - 70., pos.y), camp_grade, PowerUpType::DamageReductionUp);
    enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(pos.x - 20., pos.y + 100.), camp_grade, PowerUpType::AttackSpeedUp);
    enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(pos.x + 40. , pos.y + 20.), camp_grade, PowerUpType::MovementSpeedUp);
    enemy::spawn_enemy(&mut commands, &entity_atlas, 0, campid, Vec2::new(pos.x + 100., pos.y + 100.), camp_grade, PowerUpType::MaxHPUp);
}

pub fn handle_camp_clear(
    mut camp_query: Query<(&Camp, &CampEnemies, &mut CampStatus), With<Camp>>,
){
    for (camp_num, enemies_in_camp, mut camp_status) in camp_query.iter_mut(){
        
        // only let this happen for camps that are currently active
        if camp_status.status {
            //set the camp as cleared if all enemies are gone
            if enemies_in_camp.current_enemies == 0 {
                camp_status.status = false;
                println!("camp {} cleared", camp_num.0)
            }
            
        }
    }
}

// convert given row and col into x and y coordinates. Returns a vec2 of these coordinates
fn get_spawn_vec(row: f32, col:f32) -> Vec2{
    let x_coord = TILESIZE as f32 * (col - (MAPSIZE as f32/2.));
    let y_coord = TILESIZE as f32 * ((MAPSIZE as f32/2.) - row);

    Vec2::new(x_coord, y_coord)
}